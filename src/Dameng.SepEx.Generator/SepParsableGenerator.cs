using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.SepEx.Generator;

[Generator]
public class SepParsableGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            foreach (var typeDeclaration in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (typeDeclaration is not ClassDeclarationSyntax and not StructDeclarationSyntax)
                    continue;
                var targetType =
                    semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;

                if (targetType is null)
                {
                    continue;
                }

                var attributes = targetType.GetAttributes();

                // Handle GenSepParsable attribute FIRST and independently
                var genParsableAttribute = attributes.FirstOrDefault(attribute =>
                    attribute
                        .AttributeClass!.ToDisplayString()
                        .Equals("Dameng.SepEx.GenSepParsableAttribute")
                );

                if (genParsableAttribute is not null)
                {
                    StringBuilder genClassCodeBuilder = new StringBuilder();
                    genClassCodeBuilder.AppendLine(
                        $$"""
                          // <auto-generated at {{DateTimeOffset.Now:O}}/>
                          using System;
                          using Dameng.SepEx;

                          namespace {{targetType.ContainingNamespace.ToDisplayString()}};

                          """
                    );

                    var (initCode, writeCode) = Utils.GeneratePropertyCode(
                        targetType,
                        context
                    );

                    var accessibility =
                        targetType.DeclaredAccessibility is Accessibility.Public ? "public" : "internal";

                    genClassCodeBuilder.Append(
                        $$"""
                          {{accessibility}} partial class {{targetType.Name}} : ISepParsable<{{targetType.ToDisplayString()}}>
                          {
                              public static {{targetType.ToDisplayString()}} Read(nietras.SeparatedValues.SepReader reader, nietras.SeparatedValues.SepReader.Row readRow) 
                              {
                          {{initCode}}
                              }

                              public static void Write(nietras.SeparatedValues.SepWriter writer,nietras.SeparatedValues.SepWriter.Row writeRow, {{targetType.ToDisplayString()}} value)
                              {
                          {{writeCode.TrimEnd()}}
                              }
                          }
                          """
                    );

                    context.AddSource(
                        targetType.Name + ".SepParsable.g.cs",
                        SourceText.From(genClassCodeBuilder.ToString(), Encoding.UTF8)
                    );
                }
            }
        }
    }
}
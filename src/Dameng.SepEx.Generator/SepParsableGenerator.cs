using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Dameng.SepEx.Generator;

[Generator]
public class SepParsableGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    private static string GetPartialTypeDeclaration(INamedTypeSymbol typeSymbol)
    {
        var typeName = typeSymbol.Name;
        
        // Check if it's a record
        if (typeSymbol.IsRecord)
        {
            // Check if it's a record struct
            if (typeSymbol.IsValueType)
            {
                return $"partial record struct {typeName}";
            }
            else
            {
                return $"partial record {typeName}";
            }
        }
        // Check if it's a struct (but not a record struct)
        else if (typeSymbol.IsValueType)
        {
            // Check if it's readonly struct by looking at the declaration
            // Note: We can't easily detect readonly from INamedTypeSymbol, but we'll generate regular partial struct
            return $"partial struct {typeName}";
        }
        // Default to class
        else
        {
            return $"partial class {typeName}";
        }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            foreach (var typeDeclaration in syntaxTree.GetRoot().DescendantNodesAndSelf())
            {
                if (typeDeclaration is not ClassDeclarationSyntax and not StructDeclarationSyntax and not RecordDeclarationSyntax)
                    continue;
                var targetType =
                    semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;

                if (targetType is null)
                {
                    continue;
                }

                var attributes = targetType.GetAttributes();

                // Handle GenSepParsable attribute FIRST and independently
                var genParsableAttribute = attributes.FirstOrDefault(attribute =>
                    attribute
                        .AttributeClass!.ToDisplayString()
                        .Equals("Dameng.SepEx.GenSepParsableAttribute")
                );

                if (genParsableAttribute is not null)
                {
                    StringBuilder genClassCodeBuilder = new StringBuilder();
                    genClassCodeBuilder.AppendLine(
                        $$"""
                          //------------------------------------------------------------------------------ 
                          // <auto-generated> 
                          // This code was generated at {{DateTimeOffset.Now:O}}. 
                          // Generator: {{nameof(SepParsableGenerator)}}
                          // Assembly: {{typeof(SepParsableGenerator).Assembly.FullName}}
                          // </auto-generated> 
                          //------------------------------------------------------------------------------
                          
                          using System;
                          using Dameng.SepEx;

                          namespace {{targetType.ContainingNamespace.ToDisplayString()}};

                          """
                    );

                    var (initCode, writeCode) = Utils.GeneratePropertyCode(
                        targetType,
                        context
                    );
                    
                    var partialTypeDeclaration = GetPartialTypeDeclaration(targetType);

                    if (targetType.ContainingType is null)
                    {
                        // Top-level class - use original logic
                        genClassCodeBuilder.Append(
                            $$"""
                              {{partialTypeDeclaration}} : ISepParsable<{{targetType.ToDisplayString()}}>
                              {
                                  public static {{targetType.ToDisplayString()}} Read(nietras.SeparatedValues.SepReader reader, nietras.SeparatedValues.SepReader.Row readRow) 
                                  {
                              {{initCode}}
                                  }

                                  public static void Write(nietras.SeparatedValues.SepWriter writer,nietras.SeparatedValues.SepWriter.Row writeRow, {{targetType.ToDisplayString()}} value)
                                  {
                              {{writeCode.TrimEnd()}}
                                  }
                              }
                              """
                        );
                    }
                    else
                    {
                        // Nested class - build proper containment structure
                        genClassCodeBuilder.Append(GenerateNestedClassStructure(targetType,  initCode, writeCode));
                    }

                    // Just change the filename for now as a test
                    var fileName = targetType.ContainingType is not null 
                        ? targetType.ToDisplayString().Replace(".", "_") + ".SepParsable.g.cs"
                        : targetType.Name + ".SepParsable.g.cs";
                        
                    context.AddSource(
                        fileName,
                        SourceText.From(genClassCodeBuilder.ToString(), Encoding.UTF8)
                    );
                }
            }
        }
    }

    private static string GenerateNestedClassStructure(INamedTypeSymbol targetType,  string initCode, string writeCode)
    {
        // Build the list of containing classes from outermost to innermost
        var containers = new List<INamedTypeSymbol>();
        var current = targetType.ContainingType;
        while (current is not null)
        {
            containers.Add(current);
            current = current.ContainingType;
        }
        
        // Reverse to get from outermost to innermost
        containers.Reverse();
        
        // Build the nested structure
        var nestedTypeDeclaration = GetPartialTypeDeclaration(targetType);
        var targetClassDef = $$"""
            {{nestedTypeDeclaration}} : ISepParsable<{{targetType.ToDisplayString()}}>
            {
                /// <inheritdoc/>
                public static {{targetType.ToDisplayString()}} Read(nietras.SeparatedValues.SepReader reader, nietras.SeparatedValues.SepReader.Row readRow) 
                {
            {{initCode}}
                }
            
                /// <inheritdoc/>
                public static void Write(nietras.SeparatedValues.SepWriter writer,nietras.SeparatedValues.SepWriter.Row writeRow, {{targetType.ToDisplayString()}} value)
                {
            {{writeCode.TrimEnd()}}
                }
            }
            """;
        
        // Wrap in container classes
        var result = targetClassDef;
        for (int i = containers.Count - 1; i >= 0; i--)
        {
            var container = containers[i];
            var containerAccessibility = container.DeclaredAccessibility is Accessibility.Public ? "public" : "internal";
            var indent = new string(' ', (containers.Count - 1 - i) * 4);
            
            // Add indentation to current result
            var indentedResult = string.Join("\n", 
                result.Split('\n').Select(line => 
                    string.IsNullOrWhiteSpace(line) ? line : "    " + line));
            
            result = $$"""
                     {{indent}}{{containerAccessibility}} partial class {{container.Name}}
                     {{indent}}{
                     {{indentedResult}}
                     {{indent}}}
                     """;
        }
        
        return result;
    }
}